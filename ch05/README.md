# 5 Applying a Microservice Architecture to Your Enterprise Application
- This chapter focuses on highly scalable architectures using microservices, which are small modules that enable fine-grained scaling and independent evolution. The chapter covers the concept of microservices, their benefits, how .NET handles them, and the necessary tools for managing microservices. By the end of the chapter, you will have gained knowledge on implementing a microservice in .NET.

## What are microservices?
- Microservice architectures provide independent scalability of modules, reducing resource waste and overall cost. They enable the development, maintenance, and deployment of software modules independently. This improves the CI/CD cycle by allowing scaling on different hardware, eliminating compatibility constraints, simplifying job organization, utilizing appropriate technologies, matching developers' competencies, and integrating legacy subsystems with newer ones. The section also discusses the origins of microservices and their design principles, including the use of Docker containers.

### Microservices and the evolution of the concept of modules
- Microservices represent an evolution in the concept of deployment modularity, building upon the foundations of code modularity. They emerged as a response to the limitations of DLL-based modularity and the challenges of version compatibility. The progression from monolithic executables to static libraries, dynamic link libraries (DLLs), and then to platforms like .NET and Java facilitated deployment on different hardware and operating systems. However, the inability to handle different versions of shared dependencies led to the adoption of package management systems and Service-Oriented Architecture (SOA), where deployment units were implemented as web services. Microservices, as an evolution of SOA, enhance scalability and modularity, improving the CI/CD cycle. They are considered a refined implementation of SOA with additional features and constraints.

### Microservices design principles
- The microservice architecture is an extension of SOA that emphasizes independence and fine-grained scaling. Understanding the benefits of microservice independence and scaling, we can now explore the design principles that stem from these constraints. Each principle will be discussed in its own subsection.

#### The independence of design choices
- The principle of independence of design choices in microservices ensures that each microservice can have its own independent design and implementation decisions. This allows for flexibility in choosing the most suitable technologies for each microservice. Additionally, microservices should not share the same storage, as this would entail sharing design choices and structure. Instead, microservices can have dedicated data storage, either by having exclusive access to a separate database or by implementing a logical microservice split into multiple physical microservices for better load balancing.

#### Independence from the deployment environment
- Microservices should be independent from the deployment environment. They should not rely heavily on services provided by the operating system or other installed software. By being less dependent on the environment, microservices can be deployed on a wider range of hardware nodes and allow for better optimization. This is why microservices are often containerized using technologies like Docker. Containerization enables each microservice to package its dependencies, making it portable and capable of running anywhere.

#### Loose coupling
- The principle of loose coupling in microservices involves two aspects. Firstly, the interface exposed by each microservice should be general rather than specific, following object-oriented programming principles. Secondly, the communication among microservices should be minimized to reduce costs. Since microservices run on different hardware nodes and do not share the same address space, minimizing communication helps maintain loose coupling and improves overall system efficiency.

#### No chained requests/responses
- The principle of no chained requests/responses in microservices states that a microservice should not trigger a recursive chain of nested requests/responses to other microservices, as it would result in unacceptable response times. This can be avoided by synchronizing the private data models of microservices through push events, ensuring that each microservice has all the necessary data to serve incoming requests without needing to rely on other microservices for data retrieval. Communication of data changes should be done through asynchronous messages to prevent performance issues caused by synchronous nested messages. Additionally, best practices for building a reusable service-oriented architecture (SOA) are automatically enforced by tools and frameworks used to implement web services. Fine-grained scaling of microservices requires complex infrastructure and resilience measures to handle communication and failures, such as exponential retries and circuit break strategies. Congestion propagation is prevented through bulkhead isolation techniques, and designers should strive to make messages idempotent to avoid duplicate processing. Techniques like message identification and storage can help ensure idempotency. Message brokers like Azure Service Bus offer facilities to implement these techniques.

### Containers and Docker
- Containers and Docker provide a solution for deploying microservices that are independent of the hosting environment. Containers are a lightweight form of virtual machines that virtualize the OS filesystem level without the overhead of starting a whole OS for each instance. Docker is a popular container image format and runtime that allows the creation of isolated environments for containers. Images are built by layering new files and configuration information on top of existing images, and they can be grouped into public or private registries. Docker Compose is a tool used to specify the deployment of multiple images and how their internal resources are mapped to the host machine's resources. Containerized microservices are often deployed and load-balanced on clusters managed by orchestrators. Understanding microservices, their advantages, and design principles allows us to determine when and how to use them in our system architecture.

## When do microservices help?
1. Layered architectures and microservices
2. When is it worth considering microservice architectures?
