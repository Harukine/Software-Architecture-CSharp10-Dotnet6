# Interacting with Data in C# - Entity Framework Core
- Object-Relational Mapping (ORM) and its importance in building data layers for enterprise applications. We discuss the basics of ORM and its role in mapping data between the storage subsystem and objects. We then dive into Entity Framework Core, a popular ORM tool included in .NET 6. We cover the configuration of Entity Framework Core and discuss how to perform database migrations to manage schema changes. Additionally, we explore compiled models and how they can improve performance.
- We also delves into querying and updating data using Entity Framework Core, providing examples and best practices. We discuss deploying the data layer and highlight advanced features of Entity Framework Core, such as global filters. You will have a solid understanding of ORM, Entity Framework Core, and how to effectively work with data in C# applications.

## Understanding ORM basics
- We explore Object-Relational Mapping (ORM) and its significance in data layer implementation. We learn how ORMs map database tables to in-memory objects and vice versa, with various data types being mapped accordingly. We discuss the use of data annotations, name conventions, and the fluent configuration interface in Entity Framework Core for configuring the ORM.
- We also examine the importance of ORM providers or connectors, which are specific adapters for different database types, and Entity Framework Core's support for various database engines. We explore how relationships between tables are represented using object pointers and how the DbContext class acts as an in-memory cache class containing the mapping configuration.
- Querying and updating data using Entity Framework Core is covered, with LINQ queries and lazy evaluation discussed. We see how updates, deletions, and additions to the database are performed through modifications to the in-memory collections representing the tables, followed by explicit synchronization with the database using methods like SaveChangesAsync().
- Transactions play a crucial role in synchronization operations, with changes being executed within a single transaction. We conclude the chapter with a deeper understanding of how Entity Framework Core handles data interactions and synchronization with the database.

## Configuring Entity Framework Core
- We can configure Entity Framework Core by creating a separate class library project. Choose a .NET 6 library project and add the necessary dependencies, such as the Microsoft.EntityFrameworkCore.SqlServer package for SQL Server integration.
- Rename the default Class1 class to MainDbContext and define it as a subclass of DbContext. The MainDbContext class requires the DbContextOptions in its constructor, which contains the necessary options for the database connection.
- Inside the MainDbContext class, we will add properties for each collection that represents a mapped database table. The mapping configuration will be defined within the OnModelCreating method using the ModelBuilder object.
- To continue the configuration, we create entity classes for each database table, which are referred to as entities. These entity classes are placed in the Models folder of the project.

### Defining DB entities
- Create an entity class called Destination to represent the rows of the location database table. The Destination class includes properties such as Id, Name, Country, and Description, which map to the corresponding DB fields. We apply attributes like MaxLength and Required to specify length limits and mandatory fields.
- Since the Destination entity is connected to the Package entity through a one-to-many relationship, it includes a collection property called Packages to refer to the related packages. The Destination class is placed in the Models folder and is decorated with appropriate attributes.
- Define the Package entity class, which represents the travel packages table. It includes properties such as Id, Name, Description, Price, DurationInDays, StartValidityDate, EndValidityDate, MyDestination, and DestinationId. We apply attributes to specify length limits and define the foreign key relationship with the Destination entity.
- The DestinationId property acts as the external key for the one-to-many relationship between packages and destinations. By explicitly representing the foreign key, we can simplify update operations and queries.
